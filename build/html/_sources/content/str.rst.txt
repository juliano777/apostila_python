Strings
*******

    Em Ciências da Computação chamamos de string um texto, também conhecido como cadeia de caracteres.
    Strings representam textos, frases ou palavras.
    É um recurso muito caro em termos de recursos computacionais (processamento e memória) e que portanto deve ser utilizado com cuidado, pois escalabilidade é algo que deve ser sempre um fator a ser levado em conta.
    
    https://docs.python.org/3/library/string.html

# ============================================================================


Strings em Python
-----------------

    Pode-se usar tanto entre aspas como entre apóstrofos.



Declaração de uma variável string utilizando apóstrofos:

> s1 = 'string'



Declaração de uma variável string utilizando aspas:

> s2 = "string"



Declaração de uma variável string utilizando a função str:

> s = str('foo')

# ============================================================================



Apóstrofos ou aspas? Qual devo utilizar?
----------------------------------------


    Se não tivessem essas duas opções, se fosse apenas aspas como em outras linguagens, em uma string que precisa ter aspas, seria preciso escapar com a contrabarra desta maneira: \". O que também funcionaria.
    Fazer uso de contrabarra para escapar por muitas vezes pode ser um tanto confuso e tornar o código menos legível.
    Com a facilidade de se poder utilizar ambos torna o escape desnecessário para a maioria dos casos em que aspas ou apóstrofos façam parte de uma string.



Dois exemplos com print de strings com aspas e apóstrofos dentro:

> print('Uma string que contém "aspas" em si')

Uma string que contém "aspas" em si

> print("Uma string que contém 'apóstrofos' em si")

Uma string que contém 'apóstrofos' em si



Um caso clássico é em strings com um comando SQL:

> sql = "SELECT * FROM musica WHERE artista = 'Mozart';"



Exibindo o conteúdo da variável:

> print(sql)

SELECT * FROM musica WHERE artista = 'Mozart';

# ============================================================================


Strings de Múltiplas Linhas
---------------------------

    

É possível se fazer uma string de múltiplas linhas quando colocamos como fechamento e abertura três apóstrofos ou aspas:

> s1 = '''
Um 
exemplo
de string
de várias 
linhas
'''

> s2 = """
Um 
exemplo
de string
de várias 
linhas
"""



Utilizando parênteses para um string longa sem quebrar linha:

> s3 = ('Um exemplo de string feito para não ultrapassar os setenta e nove '
      'caracteres da PEP8 (Python Enhancement Proposal), Proposta de '
      'aprimoramento do Python, que visa boas práticas de programação.')



> print(s3)
Um exemplo de string feito para não ultrapassar os setenta e nove caracteres da PEP8 (Python Enhancement Proposal), Proposta de aprimoramento do Python, que visa boas práticas de programação.



# ============================================================================

Caracteres Especiais
--------------------

+---------------------+----------------------------------------------------------+-----------------+------------+
| Sequência de Escape | Descrição                                                | Exemplo (print) | Saída      |
----------------------+----------------------------------------------------------+-----------------+------------+
| \\                  | Imprime uma contrabarra                                  | '\\'            | \          |
|                     |                                                          |                 |            |
| \'                  | Imprime um apóstrofo                                     | '\''            | '          |
|                     |                                                          |                 |            |
| \"                  | Imprime uma aspa                                         | '\"'            | "          |
|                     |                                                          |                 |            |
| \a                  | ASCII bell (beep)                                        | '\a'            |            |
|                     |                                                          |                 |            |
| \b                  | ASCII backspace (BS) remove o caractere anterior         | 'Casas\b '      | Casa       |
|                     |                                                          |                 |            |
| \f                  | ASCII formfeed (FF)                                      | 'foo\fbar'      | foo        |
|                     |                                                          |                 |    bar     |
|                     |                                                          |                 |            |
| \n                  | ASCII linefeed (LF)                                      | 'foo\nbar'      | foo        |
|                     |                                                          |                 | bar        |
|                     |                                                          |                 |            |
| \N{name}            | Imprime um caractere da base de dados Unicode            | '\N{DAGGER}'    | †          |
|                     |                                                          |                 |            |
| \r                  | ASCII carriage return (CR)                               | 'foo\rbar'      | bar        |
|                     |                                                          |                 |            |
| \t                  | ASCII horizontal tab (TAB) Imprime TAB                   | 'foo\tbar'      | foo    bar |
|                     |                                                          |                 |            |
| \v                  | ASCII vertical tab (VT)                                  | 'foo\vbar'      | foo        |
|                     |                                                          |                 |    bar     |
|                     |                                                          |                 |            |
| \uxxxx              | Imprime 16-bit valor hexadecimal de caractere Unicode    | '\u041b'        | Л          |
|                     |                                                          |                 |            |
| \Uxxxxxxxx          | Imprime 32-bit valor hexadecimal de caractere Unicode    | '\U000001a9'    | Ʃ          |
|                     |                                                          |                 |            |
| \ooo                | Imprime o character baseado em seu valor octal           | '\077'          | ?          |
|                     |                                                          |                 |            |
| \xhh                | Imprime o character baseado em seu valor hexadecimal     | '1\xaa'         | 1ª         |
+---------------------+----------------------------------------------------------+------------------------------+

# ============================================================================

Formatação
----------

    Há casos que é necessário fazer formatação de strings colocando uma string como um template.
    Inicialmente tinha-se a interpolação que utiliza o sinal de porcentagem (%), posteriormente foi adicionado o método format.


Interpolação:

> '%s %s' % ('foo', 'bar')

'foo bar'



Método format:

> '{} {}'.format('foo', 'bar')

'foo bar'



Valores numéricos decimais:

> '%d %d' % (70, 90)

> '{} {}'.format(70, 90)

'70 90'



Interpolação pegando o valor de um dicionário:

> print('%(variavel)s' % {'variavel': 'valor'})

valor



Variável que vai receber os valores formatados:

> foo = '''Produto: %(prod)s
Preco: R$ %(preco).2f
Cód: %(cod)05d
'''



Declaraçãoi de um dicionário que conterá as chaves e valores desejados:

> d = {'prod': 'Pente', 'preco': 3.5, 'cod': 157}



Exibindo o resultado via interpolação:

> print(foo % d)

Produto: Pente
Preco: R$ 3.50
Cód: 00157



Exibindo o resultado via método format:

> print(foo.format(**d))

Produto: Pente
Preco: R$ 3.50
Cód: 00157



String com índice posicional:

> 'O {1} {2} quando é {0}.'.format('compartilhado', 'conhecimento', 'aumenta')

'O Conhecimento aumenta quando se compartilhado'



Métodos String e de Representação

    Em objetos temos os dunders str e repr ("__str__" e "__repr__") que podem ser usados em uma string.



Criação de uma classe de exemplo:

> class Foo(object):

    def __str__(self):
        return 'STRING'

    def __repr__(self):
        return 'REPRESENTAÇÃO'



Valores dos métodos __str__ e __repr__ da classe Foo:

> '%s %r' % (Foo(), Foo())

> '{0!s} {0!r}'.format(Foo())

'STRING REPRESENTAÇÃO'



Método de representação e em caracteres ASCII:

> '%r %a' % (Foo(), Foo())

> '{0!r} {0!a}'.format(Foo())

'REPRESENTAÇÃO REPRESENTA\\xc7\\xc3O'



Preenchimento (padding) e Alinhamento de Strings



Alinhamento à direita dentro de 7 colunas:

> '%7s' % 'foo'

> '{:>7}'.format('foo')

'    foo'



Alinhamento à esquerda dentro de 7 colunas:

> '%-7s' % 'foo'

> '{:7}'.format('foo')

> '{:<7}'.format('foo')

'foo    '



Alinhamento centralizado dentro de 7 colunas:

> '{:^7}'.format('foo')

'  foo  '



Alinhamento à esquerda dentro de 7 colunas preenchendo com o caractere "_":

> '{:_<7}'.format('foo')

'foo____'



Alinhamento à direita dentro de 7 colunas preenchendo com o caractere "_":

> '{:_>7}'.format('foo')

'____foo'



Alinhamento centralizado dentro de 7 colunas preenchendo com o caractere "_":

> '{:^7}'.format('foo')

'__foo__'



Número decimal:

> '{:.3f}'.format(93.85741)

'93.857'



> '{:.3f}'.format(70000)

'70000.000'


# ============================================================================

Representações de Inteiros 
--------------------------

b) Formato binário; número de saída na base 2:

> format(10, '#05b')

'0b1010'



c) Caractere; converte o inteiro para o caractere unicode correspondente:

> format(93, 'c')

']'



d) Inteiro Decimal; saída numérica na base 10 (decimal):

> format(0b111, '#05d')

'00007'



o) Formato Octal; saída numérica na base 8 (octal):

> format(9, '#05o')

'0o011'



x ou X) Formato Hexadecimal; saída numérica na base 16 (hexadecimal), a saída é conforme o "x" maiúsculo ou minúsculo:

> format(200, '#05x')

'0x0c8'

> format(200, '#05X')

'0X0C8'



n) Numérico; o mesmo que "d", exceto que ele usa as configurações de idioma (locale) para exibir caracteres:


> format(31259.74, 'n')

'31259.7'

> format(31259.75, 'n')

'31259.8'


None) Nulo; o mesmo que "d":

> format(0b111)

'7'



Para representação exponencial pode-se utilizar tanto "e" ou "E", cuja precisão padrão é 6:

> format(1000, '.3e')

'1.000e+03'

> format(1000, '.3E')

'1.000E+03'



"f" ou "F" faz exibição de número com ponto flutuante podendo determinar a precisão, cujo padrão é 6.

> format(1000, '10.2f')

'   1000.00'

> format(1000, 'F')

'1000.000000'



"g" ou "G"; formato geral. Para uma dada precisão, sendo essa precisão maior ou igual a ' (um), arredonda o número para p (precisão) de dígitos significantes:


> format(1000, '10.2G')

'     1E+03'

> format(1000, '10.3G')

'     1e+03'

> format(100000, 'g')

'100000'

> format(1000000, 'g')

'1e+06'

> format(999.5, '10.4G')

'     999.5'

> format(999.5, '10.3G')

'     1E+03'

# ============================================================================


Tipos de Strings em Python
--------------------------

    Em Python temos algumas variações de strings, cada qual é designada por um prefixo, que é uma letra que representa o tipo de string e por omissão é unicode.
    Cada tipo de string tem um prefixo, que são "b" bytes, "f" format, "r" raw e "u" unicode.



Como unicode é padrão, podemos omitir o prefixo:

> print(u'Foo' == 'Foo')

True




Bytes (b)
~~~~~~~~~

    Strings de bytes utilizam o prefixo "b" e quando contém caracteres especiais, esses são representados pelo código hexadecimal da codificação utilizada.



Criação de 3 (três) strings comuns:

> s1 = 'Sem caracteres especiais'

> s2 = 'Macarrão'

> s3 = 'Ação'



A partir das três strings criadas anteriormente, criar outras três strings, mas strings de bytes:

> sb1 = s1.encode('utf-8')

> sb2 = s2.encode('utf-8')

> sb3 = s3.encode('utf-8')

    O método encode, utilizando a codificação UTF-8 faz a codificação de cada caractere para bytes.



Exibir o conteúdo das strings de bytes:

> print(sb1)

b'Sem caracteres especiais'

> print(sb2)

b'Macarr\xc3\xa3o'


> print(sb3)

b'A\xc3\xa7\xc3\xa3o'

    As strings que tinham caracteres especiais ficaram um tanto "estranhas"...
    \xc3\xa3 -> ã
    \xc3\xa7 -> ç



Conversão de bytes:

> print(b'\xc3\xa3'.decode('utf-8'))

ã

> print(b'\xc3\xa7'.decode('utf-8'))

ç



A letra grega sigma é considerada como um caractere especial:

> print('∑'.encode('utf-8'))

b'\xe2\x88\x91'



Caminho reverso:

> print(b'\xe2\x88\x91'.decode('utf-8'))

∑



A partir das strings de bytes obter o texto:

> print(sb1.decode('utf-8'))

Sem caracteres especiais

> print(sb2.decode('utf-8'))

Macarrão

> print(sb3.decode('utf-8'))

Ação



Pode-se também criar um objeto bytes a partir da classe:

> b = bytes('∑'.encode('utf-8'))



Verificando o tipo:

> print(type(b))

<class 'bytes'>

    Uma byte string tem um tipo específico, bytes.



Exibindo a byte string:

> print(b)

b'\xe2\x88\x91'



Decodificando para unicode:

> print(b.decode('utf-8'))

∑



Verificando o tipo quando o objeto é decodificado:

> type(b.decode('utf-8'))

str

    Ao ser decodificado passa a ser uma string.


Format Strings
~~~~~~~~~~~~~~

    Ou também conhecidas como "f strings" foi um recurso adicionado à versão 3.6 de Python.

Definição de variáveis:

> marca = 'Fiat'

> modelo = '147'

> ano = 1985

> cor = 'azul'



Exibir mensagem com uma f string:

> print(f'Comprei um {marca} {modelo} {cor} ano {ano}')

Comprei um Fiat 147 azul ano 1985



Uma f string também permite que se use expressões:

> print(f'{5 + 2}')

7



Métodos e funções também são permitidos:

> print(f'{cor.upper()}')

AZUL



Criação de uma classe de exemplo que recebe quatro parâmetros:

> class Carro(object):
    # Método de inicialização (construtor)
    def __init__(self, marca, modelo, ano, cor):
        self.marca = marca
        self.modelo = modelo
        self.ano = ano
        self.cor = cor

    # Método string
    def __str__(self):
        return f'{marca} {modelo} / {cor} / {ano}'

    # Método de representação    
    def __repr__(self):
        return f'{marca} {modelo} | {cor} | {ano}'



Criação de um objeto Carro:

> c = Carro(marca, modelo, ano, cor)



Print do método __str__ do objeto:

> print(f'{c}')

Fiat 147 / azul / 1985



Print do método __repr__ do objeto:

> print(f'{c!r}')

Fiat 147 | azul | 1985



f string de múltiplas linhas:

> msg = f'Marca: {marca}\n'\
        f'Modelo: {modelo}\n'\
        f'Ano: {ano}\n'\
        f'Cor: {cor}'



Exibir a mensagem:

> print(msg)

Marca: Fiat
Modelo: 147
Ano: 1985
Cor: azul



f String entre parênteses:

> msg = (f'Marca: {marca} - '
         f'Modelo: {modelo} - '
         f'Ano: {ano} - '
         f'Cor: {cor}')



Exibir a mensagem:

> print(msg)

Marca: Fiat - Modelo: 147 - Ano: 1985 - Cor: azul



Raw Strings (r)

    É o tipo de string cujo conteúdo é interpretado literalmente.



Exemplo de print com raw string:

> print(r'foo\tbar')

foo\tbar

    É de se notar que a string não teve interpretação do caractere especial de tab (\t), ou seja, não houve qualquer interpretação.



Unicode Strings (u)

    É o padrão para uma string em Python, não há a necessidade de adicionar o sufixo "u" antes do apóstrofo ou aspas.



Comparação de strings:

> u'Foo' == 'Foo'

True

    Das duas strings, somente a primeira tem o sufixo "u".

# ============================================================================



Operações de Strings
--------------------

Concatenação:

> print("Curso" + " de " + "Python")

Curso de Python

> spam = "Curso".__add__(" de ".__add__("Python"))

> print(spam)

Curso de Python



Multiplicação:

> print('<' + 'Python' * 3 + '>')

<PythonPythonPython>

> print('<' + 'Python'.__mul__(3) + '>')

'<PythonPythonPython>'



Split - Quebra a string em palavras formando uma lista:

> print('Curso de Python'.split())

['Curso', 'de', 'Python']

> print('Curso de Python'.split('de'))

['Curso ', ' Python']


Slice - Corte de string - 'string'[inicio:fim - 1:incremento]:

> print("Curso de Python”[0])

'C'

> print("Curso de Python"[1:5])

'urso'

> print("Curso de Python"[1:5:2])

'us'

> print("Curso de Python"[9:])

'Python'

> print("Curso de Python"[:5])

'Curso'

> print("Curso de Python"[::])

'Curso de Python'

> print("Curso de Python"[::-1]) # String reversa

'nohtyP ed osruC'



Docstrings
----------

	São strings que vêm logo após a definição de uma função, de um método ou de uma classe.
	É muito útil para fins de documentação.
	Para visualizar o conteúdo dessa string utiliza-se o atributo mágico __doc__ ou a função help.



Criação de uma função:

> def foo():
    'Uma simples função'



Exibe a docstring da função:

> print(foo.__doc__)

Uma simples função



Criação de função:

> def bar():
    '''
    Mais outra
    função
    que não faz 
    nada
    '''



Exibe a docstring da função:

> print(bar.__doc__)

    Mais outra
    função
    que não faz 
    nada



Criação de uma classe:

> class Foo(object):
    '''
    Uma classe
    de teste
    '''



Exibe a docstring da classe:    

> print(Foo.__doc__)

    Uma classe
    de teste



Help da classe:

> help(Foo)

Help on class Foo in module __main__:

class Foo(__builtin__.object)
 |  Uma classe
 |  de teste
 |  
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)


Imutabilidade
-------------

    Strings em Python são imutáveis.



Criação de uma string:

> foo = 'bar'


Primeiro elemento da string:

> foo[0]

'b'



Tentativa de redefinição do primeiro elemento da string:

> foo[0] = 'B'

TypeError: 'str' object does not support item assignment



Id da string:

> id(foo)

139876439773904



Criação de uma string com o mesmo nome da anterior utilizando concatenação e slice:

> foo = 'B' + foo[1:]



Verificando o Id da variável:

> id(foo)

140159122071800

    Nota-se que o Id é diferente, pois agora é outro objeto.



Exibindo o valor da variável:

> print(foo)

Bar



Criação de uma nova string:

> s = 'Black'



Id da string:

> id(s)

140159159537600



Criando uma nova string com o mesmo nome da anterior via concatenação:

s += ' Sabbath'



Id da nova variável:

> id(s)

.. code-block:: console

    140159122296368

    Novamente nota-se que o Id é diferente, pois é na verdade um novo objeto.



Exibindo a string:

> print(s)

.. code-block:: console

    Black Sabbath


Concatenação de Strings em Loops


Método 1 - Ineficaz


Criação de uma string vazia:

> s = ''



Loop de concatenação

> for i in range(50):
    s += str(i)


String pronta:

> s

.. code-block:: console

    '012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849'

Para cada iteração a referência do objeto antigo é retirada e sendo criado um novo a partir do resultado da concatenação do valor antigo com o valor de do atual e o garbage collector é acionado.
Isso faz muita alocação de memória, o que torna o desempenho horrível para coisas maiores.



Método 2 Eficaz


Criação de uma lista vazia:

> s = []


Loop de concatenação:

> for i in range(50):
    s.append(str(i))

Fazendo a junção de uma string vazia com a lista criada com seus elementos via método append:

> ''.join(s)

.. code-block:: console

    012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849'



Criando uma string via método join da lista de mesmo nome:

> s = ''.join(s)

Exibindo o valor da variável:

> s

.. code-block:: console

    '012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849'


	Foi criada uma lista de strings no loop em que a cada iteração é utilizado o método append da lista para adicionar o item atual.
	No final é utilizado o método de string join que utiliza como separador uma string vazia ('') juntando em uma string (o novo s) todos os valores da lista.
	A estrutura de dados de uma lista Python é mais eficiente para crescer, pois o método append apenas adiciona um novo elemento, de forma rápida e eficiente. O método join, que é escrito em C, que faz a junção de todos elementos concatenando em um único passo.Muito melhor do que o método anterior em que um novo objeto é criado a cada iteração.



Métodos de Strings
------------------


- join; junta elementos de uma lista ou tupla utlizando uma string.



Criação de uma lista:

> foo = list('Python')


Exibe a lista:

> print(foo)

.. code-block:: console

    ['P', 'y', 't', 'h', 'o', 'n']



Criação de uma nova variável juntando os elementos da lista com uma string vazia:

> bar = ''.join(foo)


Exibindo a nova string:

> print(bar)

.. code-block:: console

    Python


Criando uma tupla:

> foo = tuple('Python')


Exibindo os elementos da tupla:

> print(foo)

.. code-block:: console

    ('P', 'y', 't', 'h', 'o', 'n')



Criação de uma nova variável juntando os elementos da tupla com uma string vazia:

> bar = ''.join(foo)

Exibindo o valor da variável:

> print(bar)

.. code-block:: console

    Python


- find & index (diferença entre ambos)



Dada a seguinte string:

> foo = 'Python FreeBSD PostgreSQL'

Temos seus caracteres e suas respectivas posições:

P|y|t|h|o|n| |F|r|e|e |B |S |D |  |P |o |s |t |g |r |e |S |Q |L
0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24



A partir de qual posição aparece a string?:

> foo.index('FreeBSD')

> foo.find('FreeBSD')

.. code-block:: console

    7

    No exemplo dado o texto existe na string. E se não existisse?



Buscando um texto que não existe dentro da string:

> foo.index('Linux')

.. code-block:: console

    ValueError: substring not found

> foo.find('Linux')

.. code-block:: console

    -1

    Nota-se que que index lança uma exceção, enquanto find retorna -1 ao não encontrar o que foi pedido.
    O -1 não deve ser confundido como último elemento.



- count



Na frase em latim abaixo, quantas vezes aparece a letra "u"?:

> 'sic mundus creatus est'.count('u')

.. code-block:: console

    3



Quantas vezes aparece a sequência de caracteres "foo"?:

> 'XXXfooXXXfooXXXbar'.count('foo')

.. code-block:: console

    2
