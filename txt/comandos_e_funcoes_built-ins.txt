Comandos e Funções Importantes

	Neste capítulo são abordados comandos e funções interessantes e / ou imprescindíveis para a linguagem.

print

    Em Python 2 era um comando e em Python 3 passou a ser exclusivamente uma função.
    Seu objetivo é imprimir uma mensagem que por padrão é STDOUT.



Help de print:

> help(print)

    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)
    
    Imprime para um stream, or to sys.stdout por padrão.
    Argumentos opcionais:
    file:  um arquivo como um objeto (stream); o padrão é sys.stdout.
    sep:   String inserida entre valores, o padrão é um espaço.
    end:   String adicionada após o último valor, o pdarão é uma nova linha ('\n').
    flush: Se força ou não o flush (escrita) do stream, o padrão é False.

<Tradução>

    Mais detalhes sobre streams são vistos em open.



Um simples "Hello, world!":

> print('Hello, world!')

Hello, world!



Pode-se passar mais de uma string como parâmetro:

> print('foo', 'bar', 'baz')

foo bar baz



Colocando como separador uma nova linha para cada string passada como parâmetro:

> print('foo', 'bar', 'baz', sep='\n')

foo
bar
baz



range()

    É uma fun


filter

def impar(x):
    return x % 2 != 0
 

impar(7)
True

impar(6)
False

filter(impar, range(0, 20))
[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]




map 

map(len, ('spam', 'foo', 'bar', 'eggs', 'Python'))
[4, 3, 3, 4, 6]

map(type, ['foo', 1.4, 2 + 5j, 1000])
[str, float, complex, int]

map(pow, [3, 7, 5, 10], [2, 1, 7, 3])
[9, 7, 78125, 1000]



reduce

reduce(int.__add__, (2, 1, 4, 3))
10



del

	Remove referência de um objeto.
	Também apaga elemento de uma coleção.    

lista = ['a', 'b', 'c']
del lista[1]
print(lista)
['a', 'c']

sogra = 'Edelbarina'
print(sogra)
Edelbarina
del sogra
print(sogra)
NameError: name 'sogra' is not defined


http://stackoverflow.com/questions/4728073/what-is-the-difference-between-an-expression-and-a-statement-in-python

http://stackoverflow.com/questions/2220699/whats-the-difference-between-eval-exec-and-compile-in-python


Read and execute code from an object, which can be a string or a code object.

exec is not an expression: a statement in Python 2.x, and a function in Python 3.x. It compiles and immediately evaluates a statement or set of statement contained in a string. Example:

exec('print(5)')           # prints 5.
# exec 'print 5'     if you use Python 2.x, nor the exec neither the print is a function there
exec('print(5)\nprint(6)')  # prints 5{newline}6.
exec('if True: print(6)')  # prints 6.
exec('5')                 # does nothing and returns nothing.
exec('x = 7')
x
7


questão de segurança!!!

Evaluate the source in the context of globals and locals.
The source may be a string representing a Python expression or a code object as returned by compile().

eval is a built-in function (not a statement), which evaluates an expression and returns the value that expression produces. Example:

x = eval('5')              # x <- 5
x = eval('%d + 6' % x)     # x <- 11
x = eval('abs(%d)' % -100) # x <- 100
x = eval('x = 5')          # INVALID; assignment is not an expression.
x = eval('if 1: x = 4')    # INVALID; if is a statement, not an expression.

compile is a lower level version of exec and eval. It does not execute or evaluate your statements or expressions, but returns a code object that can do it. The modes are as follows:

    compile(string, '', 'eval') returns the code object that would have been executed had you done eval(string). Note that you cannot use statements in this mode; only a (single) expression is valid.
    compile(string, '', 'exec') returns the code object that would have been executed had you done exec(string). You can use any number of statements here.
    compile(string, '', 'single') is like the exec mode, but it will ignore everything except for the first statement. Note that an if/else statement with its results is considered a single statement.

http://sahandsaba.com/thirty-python-language-features-and-tricks-you-may-not-know.html



ord e chr

ord('\n')
10

ord('\r')
13

chr(13)
'\r'

chr(10)
'\n'

chr(97)
'a'

ord('a')
97




dir(obj)

	Lista atributos e métodos de um elemento.

dir(iter)

['__call__', '__class__', '__cmp__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__self__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']




pass







assert



abs(x)

abs(3)
3

abs(-3)
3


divmod(x, y)

divmod(11, 4)
(2, 3)

11 / 4, 11 % 4
(2, 3)


round(x [, p]) 

round(3.333333)
3.0

round(3.333333, 3)
3.333




callable(obj)

callable('foo')
False

def f():
    print('hello')

callable(f)
True




chr(x)

chr(120)
'x'

chr(13)
'\r'



unichr(x)

unichr(2000)
u'\u07d0'

In [181]: print(unichr(2000))


ord(x)

ord('x')
120

ߐ
ord(u'\u07d0')
2000


oct(x)

oct(9)
'011'



execfile(file)

$ cat << EOF > /tmp/foo.py
print('hello, world!')
EOF


$ python /tmp/foo.py 
hello, world!

execfile('/tmp/foo.py')
hello, world!



hash

hash('foo')
-4177197833195190597

x = 'foo'

hash(x)
-4177197833195190597

hash('bar')
327024216814240868

hash([1, 2, 3])
---------------------------------------------------------------------------


TypeError: unhashable type: 'list'





id(obj)

foo = ('x', 'y')

bar = ('x', 'y')

foo == bar
True

id(foo)
139716355830632

id(bar)
139716327551272

foo is bar
False

baz = bar

baz
('x', 'y')

baz == bar
True

baz is bar
True

id(baz)
139716327551272



len(obj)

foo = ('x', 'y', 'z', 123, 5.7)

len(foo)
5


len('Heavy Metal')
11



raw_input vs input

foo = raw_input('Digite uma string qualquer... ')
Digite uma string qualquer... bla bla bla

type(foo)
str

print(foo)
bla bla bla

x = 5

y = 2

numero = input('Digite um numero: ')
Digite um numero: 9

print(numero)
9

numero = input('Digite um numero: ')
Digite um numero: x + y

print(numero)
7


foo = input('Digite algo... ')
Digite algo... 9.3

type(foo)
float

foo = input('Digite algo... ')
Digite algo... 777

type(foo)
int

foo = input('Digite algo... ')
Digite algo... 'Python is awesome!'

type(foo)
str

foo = input('Digite algo... ')

Digite algo... Python is awesome!
  File "<string>", line 1
    Python is awesome!
                     ^
SyntaxError: unexpected EOF while parsing



Funções globals(), locals() e vars() e Comando global

	Cada uma das funções retornam dicionários de variáveis e seus respectivos valores.
	globals(): Retorna variáveis globais (escopo do módulo);
	locals(): Retorna variáveis locais (escopo local);
	vars(obj): sem argumentos é equivalente a locals(), com um argumento, equivalente a objeto.__dict__


foo = 'escopo global'


def f():
    foo = 'escopo local'
    bar = 'uma variável qualquer...'
    print(globals()['foo'])
    print(locals()['foo'])

f()
escopo global
escopo local

class Spam(object):
    foo = ''
    bar = ''
    

vars(Spam)

<dictproxy {'__dict__': <attribute '__dict__' of 'Spam' objects>,
 '__doc__': None,
 '__module__': '__main__',
 '__weakref__': <attribute '__weakref__' of 'Spam' objects>,
 'bar': '',
 'foo': ''}>


def f():
    global x
    x = 7
    

type(x)

NameError: name 'x' is not defined

f()

type(x)
int

print(x)
7



Funções min() e max()

min(0, 2, -50, 7)
-50

max(0, 2, -50, 7)
7


enumerate()

x = ('verde', 'azul', 'amarelo')

y = enumerate(x)

for i, j in y:
    print('%i - %s' % (i, j))

0 - verde
1 - azul
2 - amarelo

y = enumerate(x)

type(y)
enumerate

y.next()
(0, 'verde')

y.next()
(1, 'azul')

y.next()
(2, 'amarelo')
