Comandos e Funções Importantes

	Neste capítulo são abordados comandos e funções interessantes e / ou imprescindíveis para a linguagem.

print

    Em Python 2 era um comando e em Python 3 passou a ser exclusivamente uma função.
    Seu objetivo é imprimir uma mensagem que por padrão é STDOUT.



Help de print:

> help(print)

    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)
    
    Imprime para um stream, or to sys.stdout por padrão.
    Argumentos opcionais:
    file:  um arquivo como um objeto (stream); o padrão é sys.stdout.
    sep:   String inserida entre valores, o padrão é um espaço.
    end:   String adicionada após o último valor, o pdarão é uma nova linha ('\n').
    flush: Se força ou não o flush (escrita) do stream, o padrão é False.

<Tradução>

    Mais detalhes sobre streams são vistos em open.



Um simples "Hello, world!":

> print('Hello, world!')

Hello, world!



Pode-se passar mais de uma string como parâmetro:

> print('foo', 'bar', 'baz')

foo bar baz



Colocando como separador uma nova linha para cada string passada como parâmetro:

> print('foo', 'bar', 'baz', sep='\n')

foo
bar
baz



range()

    É uma função que retorna um objeto com uma faixa inteiros (range object).
    Muito útil para uso em loops.

Sintaxe:

    range(stop)
    range(start, stop[, step])

    start: Valor inicial da sequência, por padrão é 0 (zero).
    stop:  Valor final da sequẽncia - 1.
    step:  Valor de incremento, cujo padrão é 1 (um), quando start é maior que stop, ou seja, para se fazer uma sequência regressiva é preciso um número negativo.



Um parâmetro (stop):

> for i in range(10):
    print(i)

0
1
2
3
4
5
6
7
8
9



Dois parâmetros (start e stop):

> for i in range(3, 10):
    print(i)

3
4
5
6
7
8
9



Três parâmetros (start, stop e step):

> for i in range(1, 10, 2):
    print(i)

1
3
5
7
9



sequẽncia regressiva:

> for i in range(20, 1, -5):
    print(i)

20
15
10
5



filter

    Função que retorna um iterador produzindo os itens iteráveis para os quais a função(item) for True.



Criação de uma função que retorna True se o objeto for ímpar:

> def impar(x):
    return x % 2 != 0



Testando a função:

> impar(7)

True

> impar(6)

False



Em uma sequência de 0 a 19, pela função impar criar um objeto filter somente com os elementos ímpares e posteriormente ser convertido para lista:

> f = filter(impar, range(0, 20))

> list(f)

[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]



map

    Cria um iterador que aplica uma função para cada elemento do iterável.



Dada uma tupla com várias strings, criar uma lista com o tamanho de cada string respectivamente:

> m = map(len, ('spam', 'foo', 'bar', 'eggs', 'Python'))

> list(m)

[4, 3, 3, 4, 6]



Para cada item da lista, criar uma nova lista com seus respectivos tipos:

> m = map(type, ['foo', 1.4, 2 + 5j, 1000])

> list(m)

[str, float, complex, int]



Para cada item da primeira lista elevar (potência) ao elemento respectivo na segunda lista e criar uma nova lista com os resultados:

> m = map(pow, [3, 7, 5, 10], [2, 1, 7, 3])

> list(m)

[9, 7, 78125, 1000]



reduce

    Em Python 2 estava disponível sem a necessidade de fazer importação, hoje em Python 3 está no módulo functools.



Via loop somar todos elementos de uma tupla:

> soma = 0  # Variável que terá o valor da soma após o loop

> for i in (2, 1, 4, 3):  # Loop e incrementação
    soma += i

> print(soma)  # Exibe o resultado

10



Importando reduce de functools;

> from functools import reduce



Função reduce para executar a mesma tarefa anterior com apenas um comando:

> reduce(int.__add__, (2, 1, 4, 3))

10



del

    Pode ser tanto um comando como uma função cuja finalidade é remover a referência de um objeto.
	Também apaga elemento de uma coleção.



Teste de del em um objeto mutável (lista):

> lista = ['a', 'b', 'c']  # Definição da lista

> del lista[1]  # Apaga o segundo elemento da lista

ou

> del(lista[1])  # Equivalência ao comando anterior em forma de função

> print(lista)  # Exibe a lista após o elemento ser retirado da mesma

['a', 'c']



Teste de del para desalocar um objeto criado:

> foo = 'bar'  # Objeto string criado

> print(foo)  # Verificando o valor da string

bar

> del foo  # Apagando o objeto string

> print(foo)  # Tentativa de imprimir o valor do objeto desalocado

NameError: name 'foo' is not defined

    Nota-se que após o del não é possível mais fazer referência ao objeto.



ord e chr

    A função ord retorna o código Unicode de um caractere.
    A função chr faz o caminho inverso, ou seja, retorna um caractere dado um código Unicode. Em Python 2 chr era unichr.    



ord e chr

    A função ord retorna o código Unicode de um caractere.
    A função chr faz o caminho inverso, ou seja, retorna um caractere dado um código Unicode. Em Python 2 chr era unichr.    



Exemplos de ord e chr:

> ord('\n')  # Qual é o código Unicode para new line?

10


> chr(10)  # Qual caractere Unicode corresponde ao código 10?

'\n'


> ord('\r')  # Qual é o código unicode para carriage return?

13

> chr(13)  # Qual caractere Unicode corresponde ao código 13?

'\r'

> chr(97)  # Qual caractere Unicode corresponde ao código 97?

'a'

> ord('a')  # Qual é o código unicode para o caractere "a"?

97

> chr(120)  # Qual caractere Unicode corresponde ao código 120?

'x'

> chr(981)  # Qual caractere Unicode corresponde ao código 981?

'ϕ'



dir

	Função que lista atributos e métodos de um elemento.
    Se chamada sem nenhum argumento retorna os nomes do escopo atual.
    A chamada dessa função é correspondente ao executar o método __dir__.
    

Definição de variáeis:

> x = 0

> y = 1

> z = 2



Execução da função dir sem parâmetros:

> dir()

['In',
 'Out',
. . .
 'x',
 'y',
 'z']



A variável foi declarada no escopo?:

> 'x' and 'y' and 'y' and 'z' in dir()

True

> 'w' in dir()                                                                                                                                         

False



Criação de uma classe:

> class Pessoa(object):
    # Atributos

    nome = '' 
    rg = '' 
    cpf = 0
    email = ''
    
    # Métodos
    def saudacao(self): 
        print('Olá')

    def dizer_nome(self):
        print('Meu nome é {}'.format(self.nome))



Verificando o conteúdo da classe (atributos e métodos):

> dir(Pessoa)

['__class__',
 '__delattr__',
 '__dict__',

. . . 

 'cpf',
 'dizer_nome',
 'email',
 'nome',
 'rg',
 'saudacao']



Criação de um objeto da classe e definição de atributos:

> p = Pessoa()  # 

> p.nome = 'Chiquinho'

> p.rg = '00000000'

> p.cpf = 12345678901                                                                                                                                  

> p.email = 'chiquinho@chiquinhodasilva.xx'



Atributo __dict__, que é um dicionário que contém os atributos do objeto:

> p.__dict__                                                                                                                                           

{'nome': 'Chiquinho',
 'rg': '00000000',
 'cpf': 12345678901,
 'email': 'chiquinho@chiquinhodasilva.xx'}



Pegando o valor do atributo pelo dicionário:

> p.__dict__['nome']                                                                                                                                   

'Chiquinho'



Com o auxílio de da função dir, listar todos os métodos do objeto:

> def is_dunder(s):  # Função que servirá para a função principal
    '''
    Função que retorna True para dunder strings
    '''

    # Se começar e terminar com "__" retornar True
    if s.startswith('__') and s.endswith('__'):
        return True
    else:
        return False
   


> def mostra_metodos(objeto):
    '''
    Função que mostra em tela todos os nomes de métodos de um objeto
    '''

    # Generator que conterá os nomes dos métodos por tuple comprehension
    metodos = (metodo for metodo in dir(objeto)  # Para cada item do objeto
               if (not is_dunder(metodo)) and  # se não for um dunder
               callable(getattr(objeto, metodo))  # e se for "chamável"
              )

    # Loop para exibir os nomes dos métodos
    for i in metodos:
        print(i)



Chamando a função criada para imprimir em tela os nomes dos métodos:

> mostra_metodos(p)                                                                                                                                   

dizer_nome
saudacao


pass

    bla bla bla



assert

    bla bla bla


abs

    bla bla bla

    abs(x)



bla bla bla:

> abs(3)

3



bla bla bla:

> abs(-3)

3


bla bla bla:

> divmod(11, 4)

(2, 3)



bla bla bla:

> 11 / 4, 11 % 4

(2, 3)



bla bla bla:

> round(3.333333)

3.0



bla bla bla:

> round(3.333333, 3)
3.333



bla bla bla:

> callable('foo')

False



bla bla bla:

> def f():
    print('hello')



bla bla bla:

> callable(f)

True



bla bla bla:

> chr(x)



bla bla bla:

> chr(2000)

u'\u07d0'



bla bla bla:

> print(chr(2000))


bla bla bla:

> ord('x')

120



bla bla bla:

> ord(u'\u07d0')

2000



bla bla bla:

> oct(9)

'011'



bla bla bla:

> hash('foo')

-4177197833195190597



bla bla bla:

> x = 'foo'



bla bla bla:

> hash(x)

-4177197833195190597



bla bla bla:

> hash('bar')

327024216814240868



bla bla bla:

> hash([1, 2, 3])

TypeError: unhashable type: 'list'



bla bla bla:

> id(obj)



bla bla bla:

> foo = ('x', 'y')



bla bla bla:

> bar = ('x', 'y')



bla bla bla:

> foo == bar

True



bla bla bla:

> id(foo)

139716355830632



bla bla bla:

> id(bar)

139716327551272



bla bla bla:

> foo is bar

False



bla bla bla:

> baz = bar



bla bla bla:

> baz

('x', 'y')



bla bla bla:

> baz == bar

True



bla bla bla:

> baz is bar

True



bla bla bla:

> id(baz)

139716327551272



bla bla bla:

> len(obj)



bla bla bla:

> foo = ('x', 'y', 'z', 123, 5.7)



bla bla bla:

> len(foo)

5



bla bla bla:

> len('Heavy Metal')

11



input

    bla bla bla



bla bla bla:

> foo = input('Digite uma string qualquer... ')

Digite uma string qualquer...



bla bla bla:

> print(foo)

. . .



Funções globals(), locals() e vars() e Comando global

	Cada uma das funções retornam dicionários de variáveis e seus respectivos valores.
	globals(): Retorna variáveis globais (escopo do módulo);
	locals(): Retorna variáveis locais (escopo local);
	vars(obj): sem argumentos é equivalente a locals(), com um argumento, equivalente a objeto.__dict__



bla bla bla:

> foo = 'escopo global'



bla bla bla:

> def f():
    foo = 'escopo local'
    bar = 'uma variável qualquer...'
    print(globals()['foo'])
    print(locals()['foo'])



bla bla bla:

> f()

escopo global
escopo local



bla bla bla:

> class Spam(object):
    foo = ''
    bar = ''



bla bla bla:

> vars(Spam)

<dictproxy {'__dict__': <attribute '__dict__' of 'Spam' objects>,
 '__doc__': None,
 '__module__': '__main__',
 '__weakref__': <attribute '__weakref__' of 'Spam' objects>,
 'bar': '',
 'foo': ''}>



bla bla bla:

> def f():
    global x
    x = 7



bla bla bla:

> type(x)

NameError: name 'x' is not defined



bla bla bla:

> f()



bla bla bla:

> type(x)

int



bla bla bla:

> print(x)

7



Funções min() e max()

    bla bla bla



bla bla bla:

> min(0, 2, -50, 7)

-50



bla bla bla:

> max(0, 2, -50, 7)

7



bla bla bla:

> enumerate()



bla bla bla:

> x = ('verde', 'azul', 'amarelo')



bla bla bla:

> y = enumerate(x)



bla bla bla:

> for i, j in y:
    print('%i - %s' % (i, j))

0 - verde
1 - azul
2 - amarelo



bla bla bla:

> y = enumerate(x)



bla bla bla:

> type(y)

enumerate



bla bla bla:

> y.next()

(0, 'verde')



bla bla bla:

> y.next()

(1, 'azul')



bla bla bla:

> y.next()

(2, 'amarelo')
