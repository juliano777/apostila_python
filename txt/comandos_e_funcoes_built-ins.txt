Comandos e Funções Importantes

	Neste capítulo são abordados comandos e funções interessantes e / ou imprescindíveis para a linguagem.

print

    Em Python 2 era um comando e em Python 3 passou a ser exclusivamente uma função.
    Seu objetivo é imprimir uma mensagem que por padrão é STDOUT.



Help de print:

> help(print)

    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)
    
    Imprime para um stream, or to sys.stdout por padrão.
    Argumentos opcionais:
    file:  um arquivo como um objeto (stream); o padrão é sys.stdout.
    sep:   String inserida entre valores, o padrão é um espaço.
    end:   String adicionada após o último valor, o pdarão é uma nova linha ('\n').
    flush: Se força ou não o flush (escrita) do stream, o padrão é False.

<Tradução>

    Mais detalhes sobre streams são vistos em open.



Um simples "Hello, world!":

> print('Hello, world!')

Hello, world!



Pode-se passar mais de uma string como parâmetro:

> print('foo', 'bar', 'baz')

foo bar baz



Colocando como separador uma nova linha para cada string passada como parâmetro:

> print('foo', 'bar', 'baz', sep='\n')

foo
bar
baz



range()

    É uma função que retorna um objeto com uma faixa inteiros (range object).
    Muito útil para uso em loops.

Sintaxe:

    range(stop)
    range(start, stop[, step])

    start: Valor inicial da sequência, por padrão é 0 (zero).
    stop:  Valor final da sequẽncia - 1.
    step:  Valor de incremento, cujo padrão é 1 (um), quando start é maior que stop, ou seja, para se fazer uma sequência regressiva é preciso um número negativo.



Um parâmetro (stop):

> for i in range(10):
    print(i)

0
1
2
3
4
5
6
7
8
9



Dois parâmetros (start e stop):

> for i in range(3, 10):
    print(i)

3
4
5
6
7
8
9



Três parâmetros (start, stop e step):

> for i in range(1, 10, 2):
    print(i)

1
3
5
7
9



sequẽncia regressiva:

> for i in range(20, 1, -5):
    print(i)

20
15
10
5



filter

    Função que retorna um iterador produzindo os itens iteráveis para os quais a função(item) for True.



Criação de uma função que retorna True se o objeto for ímpar:

> def impar(x):
    return x % 2 != 0



Testando a função:

> impar(7)

True

> impar(6)

False



Em uma sequência de 0 a 19, pela função impar criar um objeto filter somente com os elementos ímpares e posteriormente ser convertido para lista:

> f = filter(impar, range(0, 20))

> list(f)

[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]



map

    Cria um iterador que aplica uma função para cada elemento do iterável.



Dada uma tupla com várias strings, criar uma lista com o tamanho de cada string respectivamente:

> m = map(len, ('spam', 'foo', 'bar', 'eggs', 'Python'))

> list(m)

[4, 3, 3, 4, 6]



Para cada item da lista, criar uma nova lista com seus respectivos tipos:

> m = map(type, ['foo', 1.4, 2 + 5j, 1000])

> list(m)

[str, float, complex, int]



Para cada item da primeira lista elevar (potência) ao elemento respectivo na segunda lista e criar uma nova lista com os resultados:

> m = map(pow, [3, 7, 5, 10], [2, 1, 7, 3])

> list(m)

[9, 7, 78125, 1000]



reduce

    Em Python 2 estava disponível sem a necessidade de fazer importação, hoje em Python 3 está no módulo functools.



Via loop somar todos elementos de uma tupla:

> soma = 0  # Variável que terá o valor da soma após o loop

> for i in (2, 1, 4, 3):  # Loop e incrementação
    soma += i

> print(soma)  # Exibe o resultado

10



Importando reduce de functools;

> from functools import reduce



Função reduce para executar a mesma tarefa anterior com apenas um comando:

> reduce(int.__add__, (2, 1, 4, 3))

10



del

    Pode ser tanto um comando como uma função cuja finalidade é remover a referência de um objeto.
	Também apaga elemento de uma coleção.



Teste de del em um objeto mutável (lista):

> lista = ['a', 'b', 'c']  # Definição da lista

> del lista[1]  # Apaga o segundo elemento da lista

ou

> del(lista[1])  # Equivalência ao comando anterior em forma de função

> print(lista)  # Exibe a lista após o elemento ser retirado da mesma

['a', 'c']



Teste de del para desalocar um objeto criado:

> sogra = 'Edelbarina'  # Objeto string criado

> print(sogra)  # Verificando o valor da string

Edelbarina

> del sogra  # Apagando o objeto string

> print(sogra)  # Tentativa de imprimir o valor do objeto desalocado

NameError: name 'sogra' is not defined

    Nota-se que após o del não é possível mais fazer referência ao objeto.


exec

    bla bla bla


http://stackoverflow.com/questions/4728073/what-is-the-difference-between-an-expression-and-a-statement-in-python

http://stackoverflow.com/questions/2220699/whats-the-difference-between-eval-exec-and-compile-in-python


Read and execute code from an object, which can be a string or a code object.

exec is not an expression: a statement in Python 2.x, and a function in Python 3.x. It compiles and immediately evaluates a statement or set of statement contained in a string. Example:


bla bla bla:

> exec('print(5)')  # prints 5.

5

> exec('print(5)\nprint(6)')  # prints 5{newline}6.

5
6

> exec('if True: print(6)')  # prints 6.

6

> exec('5')  # does nothing and returns nothing.

> exec('x = 7')  # does nothing and returns nothing.



eval

    questão de segurança!!!

Evaluate the source in the context of globals and locals.
The source may be a string representing a Python expression or a code object as returned by compile().

eval is a built-in function (not a statement), which evaluates an expression and returns the value that expression produces. Example:

bla bla bla:

> x = eval('5')  # x <- 5

> x = eval('%d + 6' % x)     # x <- 11

> x = eval('abs(%d)' % -100) # x <- 100

> x = eval('x = 5')          # INVALID; assignment is not an expression.

> x = eval('if 1: x = 4')    # INVALID; if is a statement, not an expression.

compile is a lower level version of exec and eval. It does not execute or evaluate your statements or expressions, but returns a code object that can do it. The modes are as follows:

    compile(string, '', 'eval') returns the code object that would have been executed had you done eval(string). Note that you cannot use statements in this mode; only a (single) expression is valid.
    compile(string, '', 'exec') returns the code object that would have been executed had you done exec(string). You can use any number of statements here.
    compile(string, '', 'single') is like the exec mode, but it will ignore everything except for the first statement. Note that an if/else statement with its results is considered a single statement.

http://sahandsaba.com/thirty-python-language-features-and-tricks-you-may-not-know.html



ord e chr

ord('\n')
10

ord('\r')
13

chr(13)
'\r'

chr(10)
'\n'

chr(97)
'a'

ord('a')
97



dir

    bla bla bla

dir(obj)

	Lista atributos e métodos de um elemento.

dir(iter)

['__call__', '__class__', '__cmp__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__self__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
]


pass

    bla bla bla



assert

    bla bla bla


abs

    bla bla bla

    abs(x)



bla bla bla:

> abs(3)

3



bla bla bla:

> abs(-3)

3


bla bla bla:

> divmod(11, 4)

(2, 3)



bla bla bla:

> 11 / 4, 11 % 4

(2, 3)



bla bla bla:

> round(3.333333)

3.0



bla bla bla:

> round(3.333333, 3)
3.333



bla bla bla:

> callable('foo')

False



bla bla bla:

> def f():
    print('hello')



bla bla bla:

> callable(f)

True



bla bla bla:

> chr(120)

'x'



bla bla bla:

> chr(13)

'\r'



bla bla bla:

> unichr(x)



bla bla bla:

> unichr(2000)

u'\u07d0'



bla bla bla:

> print(unichr(2000))


bla bla bla:

> ord('x')

120



bla bla bla:

> ord(u'\u07d0')

2000



bla bla bla:

> oct(9)

'011'



bla bla bla:

> execfile(file)



bla bla bla:

$ cat << EOF > /tmp/foo.py
print('hello, world!')
EOF



bla bla bla:

$ python /tmp/foo.py 
hello, world!



bla bla bla:

> execfile('/tmp/foo.py')

hello, world!



bla bla bla:

> hash('foo')

-4177197833195190597



bla bla bla:

> x = 'foo'



bla bla bla:

> hash(x)

-4177197833195190597



bla bla bla:

> hash('bar')

327024216814240868



bla bla bla:

> hash([1, 2, 3])

TypeError: unhashable type: 'list'



bla bla bla:

> id(obj)



bla bla bla:

> foo = ('x', 'y')



bla bla bla:

> bar = ('x', 'y')



bla bla bla:

> foo == bar

True



bla bla bla:

> id(foo)

139716355830632



bla bla bla:

> id(bar)

139716327551272



bla bla bla:

> foo is bar

False



bla bla bla:

> baz = bar



bla bla bla:

> baz

('x', 'y')



bla bla bla:

> baz == bar

True



bla bla bla:

> baz is bar

True



bla bla bla:

> id(baz)

139716327551272



bla bla bla:

> len(obj)



bla bla bla:

> foo = ('x', 'y', 'z', 123, 5.7)



bla bla bla:

> len(foo)

5



bla bla bla:

> len('Heavy Metal')

11



raw_input vs input

foo = raw_input('Digite uma string qualquer... ')
Digite uma string qualquer... bla bla bla

type(foo)
str

print(foo)
bla bla bla

x = 5

y = 2

numero = input('Digite um numero: ')
Digite um numero: 9

print(numero)
9

numero = input('Digite um numero: ')
Digite um numero: x + y

print(numero)
7


foo = input('Digite algo... ')
Digite algo... 9.3

type(foo)
float

foo = input('Digite algo... ')
Digite algo... 777

type(foo)
int

foo = input('Digite algo... ')
Digite algo... 'Python is awesome!'

type(foo)
str

foo = input('Digite algo... ')

Digite algo... Python is awesome!
  File "<string>", line 1
    Python is awesome!
                     ^
SyntaxError: unexpected EOF while parsing



Funções globals(), locals() e vars() e Comando global

	Cada uma das funções retornam dicionários de variáveis e seus respectivos valores.
	globals(): Retorna variáveis globais (escopo do módulo);
	locals(): Retorna variáveis locais (escopo local);
	vars(obj): sem argumentos é equivalente a locals(), com um argumento, equivalente a objeto.__dict__


foo = 'escopo global'


def f():
    foo = 'escopo local'
    bar = 'uma variável qualquer...'
    print(globals()['foo'])
    print(locals()['foo'])

f()
escopo global
escopo local

class Spam(object):
    foo = ''
    bar = ''
    

vars(Spam)

<dictproxy {'__dict__': <attribute '__dict__' of 'Spam' objects>,
 '__doc__': None,
 '__module__': '__main__',
 '__weakref__': <attribute '__weakref__' of 'Spam' objects>,
 'bar': '',
 'foo': ''}>


def f():
    global x
    x = 7
    

type(x)

NameError: name 'x' is not defined

f()

type(x)
int

print(x)
7



Funções min() e max()

min(0, 2, -50, 7)
-50

max(0, 2, -50, 7)
7


enumerate()

x = ('verde', 'azul', 'amarelo')

y = enumerate(x)

for i, j in y:
    print('%i - %s' % (i, j))

0 - verde
1 - azul
2 - amarelo

y = enumerate(x)

type(y)
enumerate

y.next()
(0, 'verde')

y.next()
(1, 'azul')

y.next()
(2, 'amarelo')
