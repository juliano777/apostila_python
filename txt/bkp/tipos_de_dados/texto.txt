.3 Texto
	string (padrão) →  str →  'palavra' (apenas caracteres ASCII)
	string unicode →  unicode →  u'palavra'
        regex string -> r'\n'


s = str('foo')

s
'foo'


	Uma string é envolta por apóstrofos ou aspas.

s1 = 'string'
s2 = "string"

	É possível se fazer uma string de múltiplas linhas quando colocamos como fechamento e abertura três apóstrofos ou aspas:

s1 = '''
Um 
exemplo
de string
de várias 
linhas
'''

s2 = """
Um 
exemplo
de string
de várias 
linhas
"""

	Também pode-se fazer uso de ambas na mesma string, como por exemplo, uma string com um comando SQL:

sql = "SELECT * FROM musica WHERE artista = 'Mozart';"

	Um artifício muito útil para evitar ficar escapando caracteres.


Strings Unicode

	Permite strings com caracteres acentuados.

s1 = u'Ambulância'

print(s1)
Ambulância

repr(s1)
"u'Ambul\\xe2ncia'"


Strings Regex

s1 = 'foo\nbar'

print(s1)
foo
bar

s1 = r'foo\nbar'

print(s1)
foo\nbar



Caracteres Especiais


Escape Sequence 	Meaning 	Notes
\newline 	Ignored 	 
\\ 	Backslash (\) 	 
\' 	Single quote (') 	 
\" 	Double quote (") 	 
\a 	ASCII Bell (BEL) 	 
\b 	ASCII Backspace (BS) 	 
\f 	ASCII Formfeed (FF) 	 
\n 	ASCII Linefeed (LF) 	 
\N{name} 	Character named name in the Unicode database (Unicode only) 	 
\r 	ASCII Carriage Return (CR) 	 
\t 	ASCII Horizontal Tab (TAB) 	 
\uxxxx 	Character with 16-bit hex value xxxx (Unicode only) 	(1)
\Uxxxxxxxx 	Character with 32-bit hex value xxxxxxxx (Unicode only) 	(2)
\v 	ASCII Vertical Tab (VT) 	 
\ooo 	Character with octal value ooo 	(3,5)
\xhh 	Character with hex value hh 	(4,5)

Notes:

    Individual code units which form parts of a surrogate pair can be encoded using this escape sequence.
    Any Unicode character can be encoded this way, but characters outside the Basic Multilingual Plane (BMP) will be encoded using a surrogate pair if Python is compiled to use 16-bit code units (the default).
    As in Standard C, up to three octal digits are accepted.
    Unlike in Standard C, exactly two hex digits are required.
    In a string literal, hexadecimal and octal escapes denote the byte with the given value; it is not necessary that the byte encodes a character in the source character set. In a Unicode literal, these escapes denote a Unicode character with the given value.





Operações de Strings – help(str)

.3.1 Concatenação

print("Curso" + " de " + "Python")
Curso de Python

print('<' + 'Python' * 3 + '>')
<PythonPythonPython>


spam = "Curso".__add__(" de ".__add__("Python"))

print(spam)
Curso de Python

.3.2 Multiplicação

print('<' + 'Python' * 3 + '>')
<PythonPythonPython>

print('<' + 'Python'.__mul__(3) + '>')
'<PythonPythonPython>'


.3.3 Split
Quebra a string em palavras formando uma lista

print('Curso de Python'.split())
['Curso', 'de', 'Python']

print('Curso de Python'.split('de')) # Com passagem de parâmetro a função formará a lista de palavras retirando a string de parâmetro
['Curso ', ' Python']


.3.4 Slice
Corte de string 'string'[inicio:fim - 1:incremento]

print("Curso de Python”[0])
'C'

print("Curso de Python"[1:5])
'urso'

print("Curso de Python"[1:5:2])
'us'

print("Curso de Python"[9:])
'Python'

print("Curso de Python"[:5])
'Curso'

print("Curso de Python"[::])
'Curso de Python'

print("Curso de Python"[::-1]) # String reversa
'nohtyP ed osruC'


sql = "SELECT campo1, campo2 FROM tabela WHERE campo3 = 'valor'"


.3.5 Interpolação

	Na interpolação de strings o caractere de porcentagem “%” é utilizado para invocar um valor (seja ele texto ou numérico) dentro de uma string ou até mesmo pra fazer algum tipo de formatação.

<ver tabela em tmp.odt>

a = "Total de itens: %d" # string que recebe um valor decimal 

print(a % 10) 
Total de itens: 10

b = "Custo: %f" # string que recebe um valor de ponto flutuante 

custo = 5.50

print(b % custo)
Custo: 5.500000

print("Cliente: %s, Valor %f" % ("Organizações XYZ", 40.30))
Cliente: Organizações XYZ, Valor 40.300000'

'''
Utiliza um número junto ao símbolo porcentagem para reservar um tamanho total à string:
'''
a = "Quantidade: %4d" 

print(a % 3)
Quantidade:    3

print(a % 53)
Quantidade:   53

print(a % 120)
Quantidade:  120

print( a % 4587)
Quantidade: 4587

print(a % 25000)
Quantidade: 25000

x = "Quantidade: %.5d" # Usando a forma %.nd, preenche com até n zeros à esquerda

print(x % 0)
Quantidade: 00000

print(x % 197)
Quantidade: 00197

print('%7s' % 'abcde')
  abcde



.3.6 Formatação

Finally, the type determines how the data should be presented.

The available string presentation types are:

    Type 	Meaning
    's' 	String format. This is the default type for strings and may be omitted.
    None 	The same as 's'.

The available integer presentation types are:

    Type 	Meaning
    'b' 	Binary format. Outputs the number in base 2.
    'c' 	Character. Converts the integer to the corresponding unicode character before printing.
    'd' 	Decimal Integer. Outputs the number in base 10.
    'o' 	Octal format. Outputs the number in base 8.
    'x' 	Hex format. Outputs the number in base 16, using lower- case letters for the digits above 9.
    'X' 	Hex format. Outputs the number in base 16, using upper- case letters for the digits above 9.
    'n' 	Number. This is the same as 'd', except that it uses the current locale setting to insert the appropriate number separator characters.
    None 	The same as 'd'.

In addition to the above presentation types, integers can be formatted with the floating point presentation types listed below (except 'n' and None). When doing so, float() is used to convert the integer to a floating point number before formatting.

The available presentation types for floating point and decimal values are:

    Type 	Meaning
    'e' 	Exponent notation. Prints the number in scientific notation using the letter ‘e’ to indicate the exponent. The default precision is 6.
    'E' 	Exponent notation. Same as 'e' except it uses an upper case ‘E’ as the separator character.
    'f' 	Fixed point. Displays the number as a fixed-point number. The default precision is 6.
    'F' 	Fixed point. Same as 'f'.
    'g' 	

    General format. For a given precision p >= 1, this rounds the number to p significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude.

    The precise rules are as follows: suppose that the result formatted with presentation type 'e' and precision p-1 would have exponent exp. Then if -4 <= exp < p, the number is formatted with presentation type 'f' and precision p-1-exp. Otherwise, the number is formatted with presentation type 'e' and precision p-1. In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it.

    Positive and negative infinity, positive and negative zero, and nans, are formatted as inf, -inf, 0, -0 and nan respectively, regardless of the precision.

    A precision of 0 is treated as equivalent to a precision of 1. The default precision is 6.
    'G' 	General format. Same as 'g' except switches to 'E' if the number gets too large. The representations of infinity and NaN are uppercased, too.
    'n' 	Number. This is the same as 'g', except that it uses the current locale setting to insert the appropriate number separator characters.
    '%' 	Percentage. Multiplies the number by 100 and displays in fixed ('f') format, followed by a percent sign.
    None 	The same as 'g'.



print('%(variavel)s' % {'variavel': 'valor'})
valor

# Variável que vai receber os valores formatados
foo = '''Produto: %(prod)s
Preco: R$ %(preco).2f
Cód: %(cod)05d'
'''

#Dicionário com os valores pra passar à variável 
bar = {
'cod': 123, 
'prod': 'pente para careca',
'preco': .5,
}

#Criação de variável por interpolação
foobar = foo % bar

print(foobar)
Produto: pente para careca
Preco: R$ 0.50 
Cód: 00123


Strings Unicode

x  = unicode('Produção', 'utf8')

print(x)
Produção

repr(x)
"u'Produ\\xe7\\xe3o'"

Strings Regex

	São strings que iniciam com um "r" antes de apóstrofos ou aspas.
	Todos caracteres detro da mesma são interpretados literalmente.
	Como o próprio nome sugere, esse tipo de string é utilizado para expressões regulares.

r = r'\n'

print(r)
\n

Docstrings

	São strings que vêm logo após a definição de uma função, de um método ou de uma classe.
	É muito útil para fins de documentação.
	Para visualizar o conteúdo dessa string utiliza-se o atributo mágico __doc__ ou a função help.

def foo():
    'Uma simples função'	

print(foo.__doc__)
Uma simples função

def bar():
    '''
    Mais outra
    função
    que não faz 
    nada
    '''    

print(bar.__doc__)

    Mais outra
    função
    que não faz 
    nada

class Foo(object):
    '''
    Uma classe
    de teste
    '''
    

In [142]: print(Foo.__doc__)

    Uma classe
    de teste

help(Foo)

Help on class Foo in module __main__:

class Foo(__builtin__.object)
 |  Uma classe
 |  de teste
 |  
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)


Imutabilidade

foo = 'bar'

foo[0]
'b'

TypeError: 'str' object does not support item assignment

id(foo)
140159160571104

foo = 'B' + foo[1:]

id(foo)
140159122071800

print(foo)
Bar

s = 'Black'

id(s)
140159159537600

s += ' Sabbath'

id(s)
140159122296368

print(s)
Black Sabbath


Concatenação de Strings em Loops


Método 1 ineficaz:

# Criação de uma string vazia
s = ''

# Loop de concatenação
for i in xrange(50):
    s += str(i)
     
# String pronta
s
'012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849'

	Para cada iteração a referência do objeto antigo é retirada e sendo criado um novo a partir do resultado da concatenação do valor antigo com o valor de do atual e o garbage collector é acionado.
	Isso faz muita alocação de memória, o que torna o desempenho horrível para coisas maiores.



Método 2 eficaz:

s = []

for i in xrange(50):
    s.append(str(i))


''.join(s)
012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849'

s = ''.join(s)

s
'012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849'


	Foi criada uma lista de strings no loop em que a cada iteração é utilizado o método append da lista para adicionar o item atual.
	No final é utilizado o método de string join que utiliza como separador uma string vazia ('') juntando em uma string (o novo s) todos os valores da lista.
	A estrutura de dados de uma lista Python é mais eficiente para crescer, pois o método append apenas adiciona um novo elemento, de forma rápida e eficiente. O método join, que é escrito em C, que faz a junção de todos elementos concatenando em um único passo.Muito melhor do que o método anterior em que um novo objeto é criado a cada iteração.


	






Métodos de Strings


- join

foo = list('Python')

print(foo)
['P', 'y', 't', 'h', 'o', 'n']

bar = ''.join(foo)

print(bar)
Python

foo = tuple('Python')

print(foo)
('P', 'y', 't', 'h', 'o', 'n')

bar = ''.join(foo)

print(bar)
Python


- find & index (dif)

foo = 'Python FreeBSD PostgreSQL'

P|y|t|h|o|n| |F|r|e|e |B |S |D |  |P |o |s |t |g |r |e |S |Q |L
0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24 

foo.index('FreeBSD')
7

foo.find('FreeBSD')
7

foo.index('Linux')
ValueError: substring not found

Lembrando que...

foo.find('Linux')
-1

foo[-1]
'L'

????

foo[foo.find('Linux')]
'L'

foo[foo.index('Linux')]
ValueError: substring not found


- count

foo.count('e')
3

foo.count('S')
2

foo.count('ee')
1

