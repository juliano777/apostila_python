Iterator

    Um iterator (iterador) permite acessar elementos de uma coleção / sequência, retornando cada elemento sequencialmente.
    Todo objeto que tiver o método __next__() é um iterator.



Criação de um iterator com uma string:

> it = iter('bar')



Representação:

> repr(it)

'<iterator object at 0x7f123cd62c50>'



Verificando métodos e atributos:

> dir(it)

['__class__',
 '__delattr__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__iter__',
 '__le__',
 '__length_hint__',
 '__lt__',
 '__ne__',
 '__new__',
 '__next__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__setstate__',
 '__sizeof__',
 '__str__',
 '__subclasshook__']

    Aqui pôde ser verificada a existência de __next__.



Executando o método __next__ até seu fim:

> it.__next__()

'b'

> it.__next__()

'a'

> it.__next__()

'r'

> it.__next__()

StopIteration:

    Bla bla bla

    Nota-se que a iteração foi feita sobre a string declarada, de forma a retornar caractere por caractere e após o último foi lançada uma exceção indicando que não há mais elementos a serem retornados.



Generator

    Um generator é um objeto iterável assim como um iterator, mas nem todo iterator é um generator.
    Funções de generator permite declarar uma função que se comporta como um iterador, podendo ser usadas em loops.
    Um generator implementa o conceito de lazy evaluation, o que faz com que em determinadas situações economize-se recursos de processamento, pois cada elemento é processado conforme a demanda.



Criando um objeto range que vai de 0  a 9:

> numeros = range(0, 10)



Se for utilizado list comrprehension será gerada uma lista:

> rq = [x ** 2 for x in numeros]



Verificando os elementos:

> rq

[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]



Verificando o tipo:

> type(rq)

list



Tuple comprehension é uma maneira de se criar um generator:

> rq = (x ** 2 for x in numeros)



Verificando o tipo do objeto:

> type(rq)

generator



Listando atributos e métodos do objeto:

> dir(rq)

['__class__',
 '__del__',
 '__delattr__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__iter__',
 '__le__',
 '__lt__',
 '__name__',
 '__ne__',
 '__new__',
 '__next__',
 '__qualname__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 'close',
 'gi_code',
 'gi_frame',
 'gi_running',
 'gi_yieldfrom',
 'send',
 'throw']



Executando o método dunder next até o fim dos elementos:

> rq.__next__()

0

> rq.__next__()

1

. . .

81

> rq.__next__()

StopIteration:

    Bla bla bla



bla bla bla:

> def gen():

    i = 0

    while i < 10:
        yield i
        i += 1



bla bla bla:

> x = gen()



bla bla bla:

> type(gen)

function

> type(x)

generator



bla bla bla:

> x.__next__()

0

. . . 

> x.__next__()

9

> x.__next__()

StopIteration:




