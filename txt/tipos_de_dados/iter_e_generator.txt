Iterator

    Um iterator (iterador) permite acessar elementos de uma coleção / sequência, retornando cada elemento sequencialmente.
    Todo objeto que tiver o método __next__() é um iterator.



Criação de um iterator com uma string:

> it = iter('bar')



Representação:

> repr(it)

'<iterator object at 0x7f123cd62c50>'



Verificando métodos e atributos:

> dir(it)

['__class__',
 '__delattr__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__iter__',
 '__le__',
 '__length_hint__',
 '__lt__',
 '__ne__',
 '__new__',
 '__next__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__setstate__',
 '__sizeof__',
 '__str__',
 '__subclasshook__']

    Aqui pôde ser verificada a existência de __next__.



Executando o método __next__ até seu fim:

> it.__next__()

'b'

> it.__next__()

'a'

> it.__next__()

'r'

> it.__next__()

StopIteration:

    Bla bla bla

    Nota-se que a iteração foi feita sobre a string declarada, de forma a retornar caractere por caractere e após o último foi lançada uma exceção indicando que não há mais elementos a serem retornados.



Generator

    Um generator é um objeto iterável assim como um iterator, mas nem todo iterator é um generator.
    Funções de generator permite declarar uma função que se comporta como um iterador, podendo ser usadas em loops.
    Um generator implementa o conceito de lazy evaluation, o que faz com que em determinadas situações economize-se recursos de processamento, pois cada elemento é processado conforme a demanda.

Iterator vs Generator

    - Para criar um generator utilizamos ou uma função com yield no lugar de return ou tuple comprehension.
    Para criar um iterador utilizamos a função iter();

    - Generator utiliza yield, iterator não;

    - Gerador salva o estado de variáveis locais a cada vez que o yield pausa o loop. Um iterador não faz uso de variáveis locais, tudo o que ele precisa é faz a iteração.



A generator may have any number of ‘yield’ statements.

You can implement your own iterator using a python class; a generator does not need a class in python.

To write a python generator, you can either use a Python function or a comprehension. But for an iterator, you must use the iter() and next() functions.

Generator in python let us write fast and compact code. This is an advantage over Python iterators. They are also simpler to code than do custom iterator.

Python iterator is more memory-efficient.



Criando um objeto range que vai de 0  a 9:

> numeros = range(0, 10)



Se for utilizado list comrprehension será gerada uma lista:

> rq = [x ** 2 for x in numeros]



Verificando os elementos:

> rq

[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]



Verificando o tipo:

> type(rq)

list



Tuple comprehension é uma maneira de se criar um generator:

> rq = (x ** 2 for x in numeros)



Verificando o tipo do objeto:

> type(rq)

generator



Listando atributos e métodos do objeto:

> dir(rq)

['__class__',
 '__del__',
 '__delattr__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__iter__',
 '__le__',
 '__lt__',
 '__name__',
 '__ne__',
 '__new__',
 '__next__',
 '__qualname__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 'close',
 'gi_code',
 'gi_frame',
 'gi_running',
 'gi_yieldfrom',
 'send',
 'throw']



Executando o método dunder next até o fim dos elementos:

> rq.__next__()

0

> rq.__next__()

1

. . .

81

> rq.__next__()

StopIteration:

    Bla bla bla



Funções Generator

    Uma função generator utiliza o comando yield em vez de return, o que faz com que retorne o próximo elemento da sequência.



Criação de uma função generator:

> def gen():

    i = 0

    while i < 10:
        yield i
        i += 1



Criação do gerador via execução da função:

> x = gen()



Verificando os tipos:

> type(gen)

function

> type(x)

generator



Execução do método __next__ até o fim:

> x.__next__()

0

. . . 

> x.__next__()

9

> x.__next__()

StopIteration:




