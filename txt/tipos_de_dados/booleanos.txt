Booleanos

    Qualquer objeto pode ser testado como um valor verdadeiro, para uso como condição em um if ou um while ou como um operando de operações "booleanas". Os seguintes valores são considerados como False: 

	False, 0, 0L, 0.0, 0j, [], (), {}, set([]), None, "" ou ''.

	Instâncias de classes definidas por usuários, se a classe define um método __nonzero__() ou __len__(), quando este método retornar o inteiro zero ou um valor booleano False.
	Todos outros valores são considerados verdadeiros, então objetos de muitos tipos são considerados como True.



Definindo a variável como True de forma indireta:

> b = bool(1)



Verificando o valor da variável:

> b

True



Definindo a variável como False de forma indireta:

> b = bool(0)



Verificando o valor da variável:

> b

False



Teste usando a lógica OR:

> True | False

True



Teste usando a lógica AND:

> True & False

False



Negação de True:

> not True

False



Negação de False:

> not False

True



bla bla bla:

> class Foo(object):
    def __nonzero__(self):
        return True



bla bla bla:

> class Bar(object):
    def __nonzero__(self):
        return False



bla bla bla:     

> foo = Foo()



bla bla bla:

> bar = Bar()



bla bla bla:

> bool(foo)

True



bla bla bla:

> bool(bar)

False



bla bla bla:

> bool(foo) & (not bool(bar))

True



bla bla bla:

> bool(foo) & bool(bar)

False



bla bla bla:

> class Spam(object):
    def __len__(self):
        return 0



Criação do objeto:

> spam = Spam()



Verificando o valor booleano:

> bool(spam)

False



bla bla bla:

> class Spam(object):
    def __len__(self):
        return 7



Criação do objeto:

> spam = Spam()



Verificando o valor booleano:

> bool(spam)

True



bla bla bla:

> class Spam(object):
    def __nonzero__(self):
        return True

    def __len__(self):
        return 0

O método __nonzero__ retorna um valor verdadeiro e o método __len__ um falso.
Com ambos declarados na mesma classe, um objeto dela o que retornará?



Criação do objeto:

> spam = Spam()



Verificando o valor booleano:

> bool(spam)

True

O retorno foi verdadeiro.
Será que isso é por causa do retorno do primeiro método ou foi feita uma lógica "OR"?


Invertendo a ordem dos métodos:

> class Spam(object):
    def __len__(self):
        return 0

    def __nonzero__(self):
        return True



Criação do objeto:

> spam = Spam()



Verificando o valor booleano:

> bool(spam)

False

Conclusão: o que prevalece é o retorno do método declarado primeiro, ou __nonzero__ ou __len__.
