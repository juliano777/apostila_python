Booleanos

    Qualquer objeto pode ser testado como um valor verdadeiro, para uso como condição em um if ou um while ou como um operando de operações "booleanas". Os seguintes valores são considerados como False: 

	False, 0, 0L, 0.0, 0j, [], (), {}, set([]), None, "" ou ''.

	Instâncias de classes definidas por usuários, se a classe define um método __nonzero__() ou __len__(), quando este método retornar o inteiro zero ou um valor booleano False.
	Todos outros valores são considerados verdadeiros, então objetos de muitos tipos são considerados como True.



Definindo a variável como True de forma indireta:

> b = bool(1)



Verificando o valor da variável:

> b

True



Definindo a variável como False de forma indireta:

> b = bool(0)



Verificando o valor da variável:

> b

False



Teste usando a lógica OR:

> True | False

True



Teste usando a lógica AND:

> True & False

False



Negação de True:

> not True

False



Negação de False:

> not False

True



Criação de classes de teste:

> class Foo(object):
    def __len__(self):
        return 1

> class Bar(object):
    def __len__(self):
        return 0



Criação de objetos:

> foo = Foo()

> bar = Bar()



Verificando o valor booleano dos objetos:

> bool(foo)

True

> bool(bar)

False



True AND (NOT False):

> bool(foo) & (not bool(bar))

True



True AND False:

> bool(foo) & bool(bar)

False



bla bla bla:

> class Spam(object):
    def __len__(self):
        return 0



Criação de objeto:

> spam = Spam()



Verificando o valor booleano:

> bool(spam)

False



bla bla bla:

> class Spam(object):
    def __len__(self):
        return 7



Criação de objeto:

> spam = Spam()



Verificando o valor booleano:

> bool(spam)

True



bla bla bla:

> class Spam(object):
    def __nonzero__(self):
        return True

    def __len__(self):
        return 0

O método __nonzero__ retorna um valor verdadeiro e o método __len__ um falso.
Com ambos declarados na mesma classe, um objeto dela o que retornará?



Criação de objeto:

> spam = Spam()



Verificando o valor booleano:

> bool(spam)

True

O retorno foi verdadeiro.
Será que isso é por causa do retorno do primeiro método ou foi feita uma lógica "OR"?


Invertendo a ordem dos métodos:

> class Spam(object):
    def __len__(self):
        return 0

    def __nonzero__(self):
        return True



Criação de objeto:

> spam = Spam()



Verificando o valor booleano:

> bool(spam)

False

Conclusão: o que prevalece é o retorno do método declarado primeiro, ou __nonzero__ ou __len__.
